---
timezone: Asia/Shanghai
---

> 请在上边的 timezone 添加你的当地时区，这会有助于你的打卡状态的自动化更新，如果没有添加，默认为北京时间 UTC+8 时区
> 时区请参考以下列表，请移除 # 以后的内容

timezone: Pacific/Honolulu # 夏威夷-阿留申标准时间 (UTC-10)

timezone: America/Anchorage # 阿拉斯加标准时间 (UTC-9)

timezone: America/Los_Angeles # 太平洋标准时间 (UTC-8)

timezone: America/Denver # 山地标准时间 (UTC-7)

timezone: America/Chicago # 中部标准时间 (UTC-6)

timezone: America/New_York # 东部标准时间 (UTC-5)

timezone: America/Halifax # 大西洋标准时间 (UTC-4)

timezone: America/St_Johns # 纽芬兰标准时间 (UTC-3:30)

timezone: America/Sao_Paulo # 巴西利亚时间 (UTC-3)

timezone: Atlantic/Azores # 亚速尔群岛时间 (UTC-1)

timezone: Europe/London # 格林威治标准时间 (UTC+0)

timezone: Europe/Berlin # 中欧标准时间 (UTC+1)

timezone: Europe/Helsinki # 东欧标准时间 (UTC+2)

timezone: Europe/Moscow # 莫斯科标准时间 (UTC+3)

timezone: Asia/Dubai # 海湾标准时间 (UTC+4)

timezone: Asia/Kolkata # 印度标准时间 (UTC+5:30)

timezone: Asia/Dhaka # 孟加拉国标准时间 (UTC+6)

timezone: Asia/Bangkok # 中南半岛时间 (UTC+7)

timezone: Asia/Shanghai # 中国标准时间 (UTC+8)

timezone: Asia/Tokyo # 日本标准时间 (UTC+9)

timezone: Australia/Sydney # 澳大利亚东部标准时间 (UTC+10)

timezone: Pacific/Auckland # 新西兰标准时间 (UTC+12)

---

# HeliosLz

1. 自我介绍

hi 大家好，我叫 Helios，希望可以和大家一起坚持下去。

2. 你认为你会完成本次残酷学习吗？

希望可以。

## Notes

<!-- Content_START -->

### 2024.07.11

笔记内容

### 2025.02.08

EPF 是什么？

EPF（Ethereum Protocol Fellowship）是以太坊核心协议开发者的培养计划，旨在降低开发者参与以太坊核心协议开发的门槛。该计划通过为期4个月的沉浸式学习和研究，帮助开发者深入理解以太坊的核心技术，并为以太坊生态系统做出实际贡献

EPF Study Group（EPF 学习小组）

为了帮助开发者更好地准备参与 EPF，以太坊基金会推出了 EPF Study Group，这是一个为期10周的学习计划，旨在为开发者提供以太坊协议的基础知识和深入技术细节。

内容：涵盖以太坊协议设计、执行层与共识层架构、测试工具、Verkle 树、分片技术、MEV（最大可提取价值）等核心主题。

形式：每周一次的在线课程，分为研究与开发两个方向，参与者还可以共同编写和扩展 epf.wiki，作为以太坊核心开发的知识库

epf.wiki 的作用

epf.wiki 是以太坊协议学习的协作知识库，由 EPF 学习小组的参与者共同创建和维护。它旨在为开发者提供以太坊核心协议的技术文档、学习资源和研究资料

功能：
* 提供以太坊协议的技术细节和核心原理。
* 作为开发者学习和贡献的开源平台。
* 帮助开发者更好地理解以太坊的底层机制

### 2025.02.09
写 Ethereum Protocol Studies Survey 2025

**重要链接**

* [市政厅电话链接](https://epf.wiki/#/eps/intro?id=participate:~:text=%E9%87%8D%E8%A6%81%E9%93%BE%E6%8E%A5-,%E5%B8%82%E6%94%BF%E5%8E%85%E7%94%B5%E8%AF%9D%E9%93%BE%E6%8E%A5,-Discord%20%E6%9C%8D%E5%8A%A1%E5%99%A8)
* [Discord 服务器](https://epf.wiki/#/eps/intro?id=participate:~:text=%E7%94%B5%E8%AF%9D%E9%93%BE%E6%8E%A5-,Discord%20%E6%9C%8D%E5%8A%A1%E5%99%A8,-%E5%85%B3%E4%BA%8E%20StreamEth%20%E7%9A%84)
* [关于 StreamEth 的每周讨论](https://epf.wiki/#/eps/intro?id=participate:~:text=Discord%20%E6%9C%8D%E5%8A%A1%E5%99%A8-,%E5%85%B3%E4%BA%8E%20StreamEth%20%E7%9A%84%E6%AF%8F%E5%91%A8%E8%AE%A8%E8%AE%BA,-YouTube)
* [YouTube](https://epf.wiki/#/eps/intro?id=participate:~:text=%E7%9A%84%E6%AF%8F%E5%91%A8%E8%AE%A8%E8%AE%BA-,YouTube,-%E4%BC%9A%E8%AE%AE%E6%97%A5%E7%A8%8B)
* [会议日程](https://epf.wiki/#/eps/intro?id=participate:~:text=YouTube-,%E4%BC%9A%E8%AE%AE%E6%97%A5%E7%A8%8B,-EPF%20%E9%82%AE%E4%BB%B6%E5%88%97%E8%A1%A8)
* [EPF 邮件列表](https://epf.wiki/#/eps/intro?id=participate:~:text=%E4%BC%9A%E8%AE%AE%E6%97%A5%E7%A8%8B-,EPF%20%E9%82%AE%E4%BB%B6%E5%88%97%E8%A1%A8,-EF%20%E5%8D%9A%E5%AE%A2)
* [EF 博客](https://epf.wiki/#/eps/intro?id=participate:~:text=EPF%20%E9%82%AE%E4%BB%B6%E5%88%97%E8%A1%A8-,EF%20%E5%8D%9A%E5%AE%A2,-%E5%91%BC%E5%8F%AB%E6%95%85%E9%9A%9C%E6%8E%92%E9%99%A4)

### 2025.02.10

开始学习小组第 0 周的内容：

**预读**
* 加密
  * 哈希
  * 公钥加密
* 数据结构
  * Merkle 树
  * 网络、p2p 和分布式系统
* 软件开发基础
  * 编程语言、编译器
* 以太坊作为平台
  * 从用户角度
  * 作为 dapp 开发者
---------------
## 加密

核心概念：
* 对称加密：使用相同的密钥加密和解密（如 AES）。
* 非对称加密：使用公钥加密，私钥解密（如 RSA, ECC）。
* 哈希函数：不可逆的单向函数，保证数据完整性（如 SHA-256, Keccak-256）。
* 数字签名：验证消息的真实性和完整性。

### AES（高级加密标准, Advanced Encryption Standard）

AES 是一种 对称加密算法，即加密和解密使用相同的密钥。

加密过程
1. 密钥扩展：将输入密钥扩展成多个子密钥（轮密钥）。
2. 初始轮：
* 轮密钥加（AddRoundKey）：将数据块与密钥进行 XOR 运算。
3. 主轮（10/12/14 轮，取决于密钥长度）：
* 字节替代 (SubBytes)：使用 S 盒进行字节级替换，提高混淆性。
* 行移位 (ShiftRows)：对状态矩阵的行进行循环移位。
* 列混合 (MixColumns)：通过矩阵变换增加扩散性（仅适用于前 n-1 轮）。
* 轮密钥加 (AddRoundKey)：再次 XOR 轮密钥。
4. 最终轮（不包含列混合）：
* 字节替代
* 行移位
* 轮密钥加

🌟 类比：使用密码箱加密文件

1. 你为密码箱设定一个密码，比如 “SuperSecret123”。
2. AES 加密过程分成多轮（10 轮/12 轮/14 轮）轮密钥
3. 初始轮：第一次锁上密码箱
* 你把你的文件放入密码箱，先用第 1 组密钥加个基础锁。
* 这相当于 AES 先用 XOR（异或）运算对数据进行初步混淆，增加安全性。
4. 主轮：多次加密，换不同的锁

  每一轮的步骤（4 个小步骤）：

  1️⃣ 字节替换（SubBytes）

  * 类比：把密码箱的每个按钮的数字都改掉，让别人猜不到。
  * 实际上，AES 通过 S 盒（Substitution Box），把数据的每个字节都随机换成其他字节，增加混淆性。

  2️⃣ 行移位（ShiftRows）

  * 类比：密码箱的按钮位置被重新排列，增加破解难度。
  * 具体操作：AES 会把数据按行排列，然后把不同的行往左移动几个字节，防止攻击者利用模式破解。

  3️⃣ 列混合（MixColumns）

  * 类比：密码箱的按钮不仅换位置，还变成了新的符号。
  * AES 通过数学运算，把数据的每一列进行混合，让数据变得更加随机，使得即使改变一点点输入，最终密文都会大幅变化。

  4️⃣ 轮密钥加（AddRoundKey）

  * 类比：使用新的子密钥换上一个新的密码锁。
  * 这一步相当于用 AES 之前生成的子密钥进行 XOR 运算，确保数据的安全性不断增加。

5. 最终轮（Final Round）——加上最后一把锁

这样就好理解多了。

**目前使用 AES 的以太坊项目有哪些？**

在以太坊生态系统中，**AES**主要用于保护用户的私钥，确保其安全性。具体而言，以太坊客户端（如 Geth）和钱包应用程序采用 AES 加密技术来加密和存储用户的私钥。这种加密方式通常涉及将用户提供的密码通过密钥导出函数（如 PBKDF2 或 scrypt）生成对称加密密钥，然后使用 AES-128-CTR 模式对私钥进行加密。加密后的私钥和相关参数被存储在称为 keystore 的文件中。

这种 keystore 文件格式被广泛应用于以太坊钱包和客户端，用于安全地存储和管理用户的私钥。用户在需要使用私钥时，只需提供正确的密码，客户端即可解密 keystore 文件，获取私钥以签署交易或进行其他操作。

### RSA（Rivest-Shamir-Adleman）

RSA 是一种 非对称加密算法，使用 公钥 加密，私钥 解密。由 Ron Rivest、Adi Shamir 和 Leonard Adleman 在 1977 年提出。RSA 依赖于大整数分解问题作为其安全基础，即很难从一个大整数中分解出两个大质数。

🔎 为什么大整数因子分解很难？

现代计算机只能用 暴力搜索 或 数学算法 来寻找大整数的因子：

1.	试除法（Trial Division）：
* 直接尝试所有可能的质数，但当 N 非常大时，效率极低。

2. 费马因子分解法（Fermat’s Factorization）：
* 适用于两个因子接近的情况。

3.	一般数域筛法（GNFS, General Number Field Sieve）：
* 目前最快的大数分解算法之一，但仍然很慢。

当 N 足够大（比如 2048 位长），现有算法需要 数千年 才能完成分解。因此，RSA 依靠这个难题来保证安全性。

**加密 & 解密流程**

<img width="319" alt="image" src="https://github.com/user-attachments/assets/477278db-4d4f-4554-87e1-a857521ec622" />

总的来说，RSA 在以太坊生态系统中的应用相对有限，主要集中在与外部系统的交互和特定的加密需求中。随着密码学的发展，ECC 和其他更先进的加密算法正在成为主流选择。

### ECC（椭圆曲线密码学, Elliptic Curve Cryptography）

ECC 是一种 非对称加密算法，基于椭圆曲线数学，提供与 RSA 相同的安全级别，但密钥长度更短。

关键特点
* 更短的密钥，更高的安全性：ECC-256 的安全性相当于 RSA-3072。
* 计算效率高：适用于资源受限的设备，如手机、硬件钱包。
* 基于椭圆曲线离散对数问题（ECDLP），比大整数分解问题更难破解。

**我们用 “爬楼梯” 来类比 ECC 的核心概念（椭圆曲线上的数学运算 & 椭圆曲线离散对数问题）。**

1️⃣ 什么是椭圆曲线上的数学运算？

椭圆曲线上的数学运算，主要是 点加法（Point Addition） 和 点倍乘（Point Multiplication）。可以想象它们是 在楼梯上跳跃的规则。

🔹 例子：爬楼梯

* 你站在 1 楼（基点  G ）。
* 你每次可以跳一步，但你不能回头（这是点加法）。
* 你也可以每次跳两倍、三倍，即  k  倍跳跃（这是点倍乘）。

<img width="399" alt="image" src="https://github.com/user-attachments/assets/fa2ffb0e-d51c-48e4-9a00-3aa528f778d7" />

2️⃣ 什么是 ECDLP（椭圆曲线离散对数问题）？

🔹 例子：神秘的电梯

	1.	你 从 1 楼（基点  G ）开始。
	2.	你按了某个神秘按钮  k ，电梯直接跳到某一层（比如 19 楼）。
	3.	问题：你能反向推算出  k （按钮按了多少次）吗？

🤔 困难之处

* 如果电梯 每次只上 1 层（线性增长），你可以数一数，知道  k = 19 。
* 但如果电梯每次跳不同的模式（如 2 倍、3 倍跳跃），你很难知道刚才发生了什么！

💡 这就是椭圆曲线离散对数问题（ECDLP）

* 你知道电梯的起点  P  和 终点  Q 。
* 但你不知道中间的操作  k ，而这个计算极其困难！

**ECC 在以太坊中的应用**

🔹 账户地址

	1.	你选一个随机数（私钥  k ），比如你选择了按电梯按钮 50 次（即  k = 50 ）。
	2.	ECC 计算公钥  Q = kG ，这相当于电梯停在了某一层（你的公钥）。
	3.	以太坊地址：对公钥进行哈希，得到 42 位的地址。

🔹 交易签名

	1.	你用你的 私钥  k  生成数字签名，保证交易来自你本人。
	2.	其他人用你的 公钥  Q  来验证签名是否正确。
	3.	但别人 无法从公钥  Q  推导出私钥  k ，确保安全性。

🔹 智能合约中的加密操作：

	1.	签名恢复：以太坊提供了ecrecover函数，允许智能合约从签名中恢复签名者的公钥，用于验证签名者的身份。
	2.	身份验证：智能合约可以利用ECC进行用户身份验证，确保只有授权用户才能执行特定操作。

🔹 去中心化应用（DApps）：

	1.	安全通信：DApps使用ECC加密用户数据，确保数据在传输和存储过程中的安全性。
	2.	数字资产管理：许多DApps依赖ECC来管理和验证用户的数字资产交易，确保交易的安全和可靠。

🔹 Layer 2 扩展解决方案：

	1.	状态通道：在状态通道中，参与者使用ECC签名离线交易，只有在需要时才将交易提交到主链，提高交易效率。
	2.	Rollup技术：Rollup方案中，批量交易被打包并提交到以太坊主链，使用ECC确保每笔交易的有效性和安全性。

### 哈希 (Hashing)

解释：
哈希是一种将任意长度的数据映射到固定长度输出的算法，输出称为哈希值或摘要。

核心概念：
* 不可逆性：无法从哈希值还原原始数据。
* 唯一性：不同的数据生成不同的哈希值。
* 抗碰撞性：找到两个不同数据产生相同哈希值的概率极低。

在以太坊中的应用：
* 账户地址：以太坊地址是公钥的 Keccak-256 哈希后截取部分数据。
* Merkle 树：用于存储交易数据，提高验证效率。
* 智能合约：数据完整性校验，如 Commit-Reveal 机制。

----------------
课程

* 协议设计
* 执行和共识层架构、规格和实现
* 测试方法和工具

当前的研究和路线图项目：
* Verkle trees
* 分片
* MEV
* 权益证明改进
* 状态和历史到期

### 2025.02.11

Week 1 | Protocol Intro

**以太坊的起源与设计理念**

* 以太坊的设计受到 UNIX 操作系统 和 自由软件运动（FOSS） 的启发。UNIX 的 模块化设计 和 Bell Labs 的开放协作环境影响了以太坊的开发方式。以太坊的目标是通过自由、开放和透明的软件赋能用户和开发者，确保 去中心化 和 信任无须信任。
* 自由软件运动 的思想对于以太坊及所有加密货币至关重要。以太坊的开发遵循 FOSS 原则，以确保软件的开放性和用户的自由，进一步保障以太坊的安全性、去中心化性和信任性。
* 密码学革命 是以太坊发展的基础。现代加密技术，尤其是 非对称加密，为 数字隐私 和 安全通信 打下了基础，影响了加密货币的发展。
* 早期的 Cypherpunk 运动也为以太坊的去中心化理念奠定了基础，他们主张建立一个基于 无信任、无边界 技术的数字世界。

**以太坊的协议设计与发展**

以太坊的设计从 比特币 和早期区块链技术中汲取灵感，最终形成了 通用区块链计算平台。最初的 白皮书 和 黄皮书 定义了以太坊的技术规范，随着时间的推移，这些设计通过 EIP（以太坊改进提案） 进行了不断的更新和改进。

以太坊的设计原则包括：
* 简单性：保持设计和实现的简洁。
* 普适性：适用于各种应用场景。
* 模块化：分解为多个可独立发展的模块。
* 非歧视性：保障每个人都能平等参与。
* 敏捷性：快速适应新变化。

**以太坊的网络架构**

* 以太坊网络由两个主要的层级构成：执行层（Execution Layer） 和 共识层（Consensus Layer）。执行层负责处理交易和管理状态（例如账户和智能合约数据），而共识层通过 权益证明（PoS） 确保网络的安全性和容错性。

**以太坊的客户端与实施**

* 以太坊有多种客户端实现，允许开发者使用不同的编程语言来实现 执行层（EL） 或 共识层（CL）。这些客户端组成了以太坊的 节点（Node），每个节点都参与以太坊网络的运作。
* 以太坊采用 客户端多样性 的策略，不依赖于单一的官方实现，确保即使某个客户端出现问题，网络的其余部分仍然能够正常运行。

**以太坊的研发与协调**

* 以太坊的开发是开放的、公开的，全球有 20多个开发团队 在共同推动以太坊的前进。不同的开发人员在不同领域内发展专业知识，并通过模块化的设计进行协作。
* 核心开发者会议（ACD） 定期讨论共识层和执行层的进展，确保以太坊的研发进程得到协调并向前推进。以太坊的改进提案（EIP）通过 社区讨论 来推动技术创新。

**以太坊的测试与验证**

* 由于以太坊协议的不断发展和多样化的客户端实现，测试成为确保网络安全的重要环节。测试工具包括 状态转换测试、模糊测试 和 RPC 测试 等，确保网络升级和新功能的稳定性。

### 2025.02.12

**学习小组第二周 | 执行层（Execution Layer）**

预读材料：

节点和客户端

1. 节点（Node）

在以太坊网络中，节点是任何参与网络的计算机系统，负责验证交易、维护区块链状态并传播信息。节点根据其角色和功能，可以分为几种类型：

1.1 全节点（Full Node）

全节点是最重要的节点类型，它存储并验证整个区块链的历史数据。全节点会下载并验证所有的区块和交易，确保每个区块都符合以太坊协议的规则。全节点负责：

* 存储整个区块链数据（包括所有交易、区块头等）。
* 验证每个新块是否符合共识规则。
* 参与网络中的共识过程，帮助确保链的安全性。
* 执行和验证每个交易（执行层部分）。

全节点有助于去中心化，因为它们不依赖于第三方进行数据验证。

1.2 轻节点（Light Node）

轻节点不保存完整的区块链数据，而是只存储与当前活动相关的数据。这使得轻节点在资源消耗上比全节点低。轻节点通过与全节点连接来获取区块头和必要的数据。它们的主要特点是：

* 只保存区块头，不存储完整的交易和状态数据。
* 依赖全节点提供交易的验证结果。
* 适用于需要低资源消耗的场景，例如手机钱包和轻量级应用。

轻节点的工作效率较高，但需要与其他全节点交互来验证交易和区块。

1.3 归档节点（Archive Node）

归档节点是全节点的一种特殊类型，它不仅存储整个区块链的数据，还存储每个区块和交易的所有历史状态。归档节点的作用是提供历史数据查询的功能，特别适用于需要审计或历史数据的情况。归档节点的特点是：

* 存储所有区块和交易的完整历史。
* 提供完整的状态数据，可以查询历史时刻的状态。
* 存储所有的帐户余额、智能合约数据等详细信息。

归档节点一般用于开发、分析和区块链数据分析场景，不常见于普通的以太坊网络使用。

2. 客户端（Client）

客户端是与以太坊网络交互的软件，负责与其他节点进行通信，并执行相关任务，如发送交易、验证区块、同步状态等。每个客户端实现了以太坊协议的不同部分，具体有多个实现版本。客户端主要负责：

* 与其他节点建立连接。
* 获取、验证和处理区块和交易。
* 与执行层、共识层以及网络层交互。

2.1 不同类型的客户端

以太坊有多个客户端实现，每个客户端都遵循相同的协议标准（以太坊协议），但是其内部实现可能有所不同。常见的以太坊客户端包括：

* Geth（Go-Ethereum）：这是最广泛使用的客户端之一，采用 Go 编程语言编写。Geth 提供了完整的以太坊节点功能，包括全节点、轻节点和矿工功能。它支持以太坊的主网、测试网和私人链。
* Besu：这是一个由 Hyperledger 项目支持的以太坊客户端，采用 Java 编写。Besu 主要面向企业和企业级解决方案，支持以太坊 1.x 和 2.x。
* Nethermind：另一个以太坊客户端实现，采用 C# 编写，注重性能和对 .NET 环境的支持。
* OpenEthereum（以前的 Parity）：这个客户端采用 Rust 编写，旨在提供高性能和轻量级的以太坊实现。它通常用于高效的交易处理和运行。
* Lighthouse、Prysm、Nimbus：这些客户端是以太坊 2.0 的实现（即信标链客户端），它们实现了以太坊的共识层，用于支持以太坊的 PoS（权益证明）机制。

2.2 客户端的功能

客户端根据其类型和功能，承担着不同的职责：

* 执行层（EL）客户端：处理交易的执行和状态更新。它通过虚拟机（EVM）执行每个交易，并更新状态树（state trie）。Geth、Besu 和 OpenEthereum 都是典型的执行层客户端。
* 共识层（CL）客户端：与 PoS（权益证明）机制相关，负责维护和验证信标链（Beacon Chain）的状态。共识层客户端如 Prysm、Lighthouse 和 Nimbus 是以太坊 2.0 的组成部分。
* P2P 网络层客户端：负责与其他节点进行通信，传播区块和交易。通过开发 P2P 协议，节点能够有效地传播信息并同步状态。

2.3 客户端交互

客户端通过以下方式与以太坊网络和其他节点进行交互：

* JSON-RPC：客户端通过 JSON-RPC 接口与网络中的其他节点交互。这些接口包括发送交易、查询区块、获取节点信息等常见操作。
* Gossip协议：节点通过 gossip 协议传播交易和区块。每当一个节点接收到新的区块或交易时，它会将其传递给其他连接的节点，确保网络中的每个节点都能同步。
* Snap Sync：这种同步机制允许节点快速同步整个链的状态，它通过下载和应用块和状态的增量更新来实现高效的同步。


以太坊：机制（基于这些幻灯片的讲座也可以在 YouTube 上观看：《以太坊执行层概述 - Dan Boneh》）

1. 执行层概述

现实生活类比：银行的交易系统

想象你在一个银行账户中进行资金转账。这就类似于以太坊中的交易和状态更新。当你发起转账时：

* 银行系统需要验证你的账户余额是否足够（类似于以太坊检查交易是否合法）。
* 然后，它会执行转账操作，将资金从一个账户转移到另一个账户（类似于以太坊执行交易并更新状态树）。
* 最后，银行系统更新你的账户余额，并将这次交易记录保存下来（类似于以太坊更新区块链的状态）。

2. 区块验证

现实生活类比：交易验证和审核

假设你去银行办理转账，银行会进行一系列的检查：

* 交易验证：检查你是否有足够的余额，转账金额是否合理，接收人的账户是否有效等。
* 状态更新：银行会根据验证结果，更新你的账户余额，并在系统中保存这次交易。

在以太坊中，每个区块都包含一组交易，执行层会逐一验证这些交易是否合法（如检查签名、余额、时间戳等）。如果某个交易不合法，整个区块会被拒绝。

3. EVM：以太坊虚拟机

现实生活类比：计算机处理器

以太坊虚拟机（EVM）类似于银行后台的计算机系统。每笔交易就像一条指令，EVM 就是执行这些指令的计算机处理器。每一条指令（如“转账”或“调用智能合约”）都会消耗一定的计算资源（类似于银行系统消耗资源处理转账）。EVM 会逐步执行这些指令，并更新状态。

4. Gas 机制

现实生活类比：交易手续费

当你去银行办理转账，银行通常会收取一定的手续费。这个手续费的多少取决于你转账的金额和银行的费用政策。以太坊中的 Gas 费用类似于这个手续费，它是执行交易和合约的代价。

* 比如，当你转账时，银行会检查你支付的手续费是否足够覆盖银行的成本，确保它能够处理你的请求。同样，以太坊会检查你支付的 Gas 是否足够覆盖执行交易的成本。

5. EIP-1559 费率机制

现实生活类比：动态收费系统

假设你在不同的时段去银行，银行可能会根据拥挤程度调整手续费：比如在高峰时段，手续费可能会增加；在低谷时段，手续费可能会降低。这类似于以太坊的 EIP-1559 机制，它通过动态调整“基础费用”（base fee），使得交易费用在网络负载较高时增加，负载较低时减少，从而确保交易的可预测性。

6. 状态转换函数（State Transition Function）

现实生活类比：银行账单

当你进行交易时，银行系统会根据你的转账记录更新你的账单状态。这个过程就像以太坊中的状态转换函数。每一笔交易都改变了账户的状态（余额），并更新到系统中。状态转换函数确保每个账户的余额和状态正确。

7. 节点类型

现实生活类比：银行不同的服务

* 全节点（Full Node）：就像银行的总账户系统，保存了所有的交易记录和账户信息，任何人都可以查询到所有的账单和历史交易。
* 轻节点（Light Node）：类似于银行的客户应用，你不需要保存所有的历史账单，只需要知道你自己的账户余额和最近的交易。
* 归档节点（Archive Node）：相当于银行的历史档案系统，专门用来存储所有的历史交易记录，可以查询过去很久以前的转账和交易信息。

8. P2P 协议：节点之间如何沟通

现实生活类比：银行之间的消息传递

当你在一个银行账户进行转账时，可能需要通过不同的银行进行资金转移。这就像以太坊的 P2P 协议，银行之间需要互相传递消息，确认转账的详细信息。在以太坊网络中，节点之间也通过 P2P 协议进行数据交换，确保每个节点都能得到最新的区块信息和交易。

9. Snap Sync

现实生活类比：银行的实时更新

当你登录银行账户时，银行会迅速同步你最新的账户信息。这就像以太坊的 Snap Sync，它能确保节点快速同步最新的区块链状态，以便他们可以更快地验证和执行交易。

* 阶段 1：类似于银行下载最新的账户和交易数据。
* 阶段 2：类似于银行确保所有账户信息和交易记录没有被篡改或遗漏。


<!-- Content_END -->
